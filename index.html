<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="color-scheme" content="light dark">
    <title>Minimalist To-Do Widget</title>
    <style>
        :root {
            /* Notion-Blue Integration (Dark Mode Default) */
            --header-bg: rgba(25, 25, 25, 0.8);
            --body-bg: rgba(25, 25, 25, 0.8);
            --line-color: rgba(85, 165, 255, 0.15);
            --text-color: #ffffff;
            --muted-color: #7a8491; /* DÃ¤mpftes Blau-Grau */
            --completed-text-opacity: 0.5;
            --completed-font-weight: 300;
            --completed-strike-color: rgba(85, 165, 255, 0.4);
            --accent-blue: #55a5ff;
            --line-completed: rgba(85, 165, 255, 0.3);
            --achievement-color: #55a5ff;
            --widget-border: 0.3cqw solid #2c2c2c;
            --widget-shadow: none;
            --widget-radius: 4cqw;
            --header-border: 0.3cqw solid rgba(85, 165, 255, 0.1);
            --input-placeholder: rgba(255, 255, 255, 0.2);
            --checkbox-glow: none;
            --streak-shadow: 0 0 3.3cqw rgba(85, 165, 255, 0.2);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --header-bg: #191919;
                --body-bg: #191919;
                --line-color: #2c2c2c;
                --text-color: #ffffff;
                --muted-color: #888888;
            }
        }

        /* Explicit Dark Theme Class */
        body.theme-dark {
            --header-bg: #191919;
            --body-bg: #191919;
            --line-color: #2c2c2c;
            --text-color: #ffffff;
            --muted-color: #888888;
            --widget-border: 0.3cqw solid #2c2c2c;
            --header-border: 0.3cqw solid rgba(85, 165, 255, 0.1);
        }

        /* Cyberpunk Theme */
        body.theme-cyberpunk {
            --header-bg: #3a0ca3;
            --body-bg: #1a0033;
            --line-color: #4cc9f0;
            --text-color: #f72585;
            --muted-color: #7b2cbf;
            --completed-text-opacity: 0.7;
            --completed-font-weight: 400;
            --completed-strike-color: #4cc9f0;
            --accent-color-1: #4cc9f0; /* Electric Blue */
            --accent-color-2: #f72585; /* Neon Pink */
            --accent-color-3: #fee440; /* Cyber Yellow */
            --accent-color-4: #3a0ca3; /* Deep Purple */
            --achievement-color: #480ca8; /* Darker Purple for Achievement */
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: var(--body-bg);
            color: var(--text-color);
            transition: background-color 0.3s ease;
            container-type: size;
            width: 100vw;
            height: 100vh;
        }

        .widget-container {
            width: 95cqw;
            height: auto;
            min-height: 95cqh;
            background: var(--body-bg);
            backdrop-filter: blur(15px) saturate(150%);
            position: relative;
            border-radius: var(--widget-radius);
            overflow: hidden;
            box-shadow: var(--widget-shadow);
            border: var(--widget-border);
            max-width: 100%;
        }

        .header {
            background-color: var(--header-bg);
            height: 16.6cqw;
            border-bottom: var(--header-border);
            margin-bottom: 6.6cqw;
            display: flex;
            align-items: center;
            padding: 0 6.6cqw;
            position: relative;
        }

        #todo-input {
            width: 100%;
            background: transparent;
            border: none;
            outline: none;
            font-size: 4.6cqw;
            color: var(--text-color);
            font-weight: 500;
        }

        #todo-input::placeholder {
            color: var(--input-placeholder);
        }

        .todo-list {
            list-style: none;
            padding: 0 5cqw;
            margin: 0;
        }

        .todo-item {
            display: flex;
            align-items: flex-end;
            margin-bottom: 3.3cqw;
            padding-bottom: 1.3cqw;
            gap: 3.3cqw;
            position: relative;
            height: 10cqw;
            cursor: grab;
            transition: transform 0.2s ease, margin 0.2s ease;
            border-bottom: 0.3cqw solid var(--line-color);
        }

        .todo-item.completed {
            border-bottom-color: var(--line-completed);
        }

        .todo-item:active {
            cursor: grabbing;
        }

        .todo-item.dragging {
            opacity: 0;
            background: rgba(0,0,0,0.05);
        }

        .checkbox {
            width: 5.5cqw;
            height: 5.5cqw;
            border: 0.4cqw solid rgba(85, 165, 255, 0.3);
            cursor: pointer;
            flex-shrink: 0;
            margin-bottom: 0.5cqw;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3.8cqw;
            font-weight: bold;
            border-radius: 1cqw;
            transition: all 0.2s ease;
        }

        .checkbox.checked {
            background-color: var(--accent-blue);
            border-color: var(--accent-blue);
            color: #191919;
            box-shadow: 0 0 2.6cqw rgba(85, 165, 255, 0.4);
        }

        .checkbox.checked::after {
            content: 'âœ“';
        }

        .text-container {
            flex-grow: 1;
            border-bottom: none; /* Lines are handled by .todo-item */
            padding-bottom: 0;
            font-size: 4.6cqw;
            min-height: 6.6cqw;
            cursor: pointer;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            color: var(--muted-color);
            transition: color 0.2s ease;
        }

        .text-container:hover {
            color: #ffffff;
        }

        #todo-input:focus + .text-container,
        #todo-input:not(:placeholder-shown) {
            color: #ffffff;
        }

        .text-container.completed {
            opacity: var(--completed-text-opacity);
            font-weight: var(--completed-font-weight);
            color: var(--muted-color); /* Muted color after strike-through */
        }

        @keyframes strike-through-animation {
            0% { transform: scaleX(0); }
            100% { transform: scaleX(1); }
        }

        .text-container.completed::before {
            content: "";
            position: absolute;
            left: 0;
            top: 50%;
            width: 100%;
            height: 0.3cqw;
            background-color: var(--completed-strike-color);
            transform-origin: left;
            transform: scaleX(1);
        }

        .text-container.completed.animating::before {
            animation: strike-through-animation 0.5s ease-out forwards;
        }

        .delete-x {
            cursor: pointer;
            color: var(--muted-color);
            font-size: 4.6cqw;
            padding-left: 1.6cqw;
            margin-bottom: 1.3cqw;
            opacity: 0.5;
        }

        .delete-x:hover {
            color: #ff5252;
            opacity: 1;
        }

        #reset-btn {
            position: absolute;
            top: 3.3cqw;
            right: 3.3cqw;
            background: none;
            border: none;
            cursor: pointer;
            color: var(--muted-color);
            display: flex;
            align-items: center;
            padding: 1.6cqw;
            border-radius: 50%;
            transition: background 0.2s;
            z-index: 10;
        }

        #reset-btn svg {
            width: 4.6cqw;
            height: 4.6cqw;
        }

        #reset-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-color);
        }

        .streak-container {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            right: 12cqw; /* Positioned left of reset-btn (3.3cqw + ~5-8cqw space) */
            display: flex;
            align-items: center;
            gap: 1.3cqw;
            font-size: 5cqw;
            font-weight: bold;
            color: var(--accent-blue);
            cursor: pointer;
            user-select: none;
            padding: 1.6cqw;
            border-radius: 2.6cqw;
            transition: all 0.2s ease;
            text-shadow: 0 0 10px rgba(85, 165, 255, 0.4);
            z-index: 5;
        }

        .streak-container:hover {
            background: rgba(128, 128, 128, 0.1);
        }

        .streak-flame {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 12cqw; /* Base size */
            height: 12cqw;
            margin-right: -5cqw;
            margin-left: -2cqw;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        .streak-flame.active {
            width: 22cqw; /* Large size when tasks are done */
            height: 22cqw;
            margin-right: -7cqw;
            margin-left: -4cqw;
        }

        .streak-flame img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            filter: none !important;
        }

        /* Error Feedback */
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            20%, 60% { transform: translateX(-1.6cqw); }
            40%, 80% { transform: translateX(1.6cqw); }
        }

        .input-error {
            animation: shake 0.4s ease-in-out;
            color: #ff5555 !important;
        }

        .input-error::placeholder {
            color: rgba(255, 85, 85, 0.4) !important;
        }

    </style>
</head>
<body class="theme-minimalist">
    <div class="widget-container">
        <div class="header">
            <input type="text" id="todo-input" placeholder="Aufgabe hinzufÃ¼gen..." maxlength="50">
            <div class="streak-container" id="streak-container" onclick="resetStreak()" title="Doppelklick zum ZurÃ¼cksetzen">
                <span class="streak-count" id="streak-count">0</span>
                <span class="streak-flame">ðŸ”¥</span>
            </div>
        </div>
        
        <div id="todo-list" class="todo-list">
            <!-- Items will be injected here -->
        </div>

        <button id="reset-btn" title="Alle lÃ¶schen">
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M23 4v6h-6"></path><path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path></svg>
        </button>
        
        </div>

    <script>
        const input = document.getElementById("todo-input");
        const listContainer = document.getElementById("todo-list");
        const resetBtn = document.getElementById("reset-btn");
        const streakCountEl = document.getElementById("streak-count");

        let todos = JSON.parse(localStorage.getItem("notion-todos-v2")) || [];
        let completedCount = parseInt(localStorage.getItem("notion-streak-v1")) || 0;

        function saveTodos() {
            localStorage.setItem("notion-todos-v2", JSON.stringify(todos));
            localStorage.setItem("notion-streak-v1", completedCount.toString());
        }

        // Default theme
        let currentTheme = localStorage.getItem("theme") || "minimalist";

        // URL Parameter Support
        const urlParams = new URLSearchParams(window.location.search);
        const themeParam = urlParams.get('theme');
        if (themeParam) {
            currentTheme = themeParam;
        }

        function applyTheme(theme) {
            document.body.className = `theme-${theme}`;
            if (!themeParam) { // Only persist if not forced by URL
                localStorage.setItem("theme", theme);
            }
        }

        function toggleTheme() {
            currentTheme = currentTheme === "minimalist" ? "dark" : "minimalist";
            applyTheme(currentTheme);
        }

        function updateStreakIcon() {
            const streakFlame = document.querySelector(".streak-flame");
            if (!streakFlame) return;
            
            // ZÃ¤hle erledigte Aufgaben in der aktuellen Liste
            const currentDone = todos.filter(t => t.completed).length;
            
            if (currentDone > 0) {
                const imgPath = `source/task${Math.min(currentDone, 5)}.png`;
                streakFlame.innerHTML = `<img src="${imgPath}" alt="Streak Flame">`;
                streakFlame.classList.add("active");
            } else {
                // Initialzustand oder 0 Aufgaben erledigt
                streakFlame.innerHTML = `<img src="source/task1.png" alt="Streak Flame" style="opacity: 0.5;">`;
                streakFlame.classList.remove("active");
            }
        }

        function renderTodos() {
            updateStreakIcon();
            streakCountEl.textContent = completedCount;
            listContainer.innerHTML = "";
            listContainer.addEventListener('dragover', handleDragOver);
            
            // Show up to 5 items
            for (let i = 0; i < 5; i++) {
                const todo = todos[i];
                const itemDiv = document.createElement("div");
                itemDiv.className = "todo-item" + (todo && todo.completed ? " completed" : "");
                
                if (todo) {
                    itemDiv.draggable = true;
                    itemDiv.dataset.index = i;
                    
                    itemDiv.addEventListener('dragstart', handleDragStart);
                    itemDiv.addEventListener('dragend', handleDragEnd);

                    itemDiv.innerHTML = `
                        <div class="checkbox ${todo.completed ? "checked" : ""}" onclick="toggleTodo(${i})"></div>
                        <div class="text-container ${todo.completed ? "completed" : ""} ${todo.animating ? "animating" : ""}" onclick="toggleTodo(${i})" style="${todo.completed ? "" : "color: #ffffff;"}">${todo.text}</div>
                        <div class="delete-x" onclick="deleteTodo(${i})">Ã—</div>
                    `;
                } else {
                    // Empty slot
                    itemDiv.innerHTML = `
                        <div class="checkbox" style="cursor: default; opacity: 0.1;"></div>
                        <div class="text-container" style="cursor: default;"></div>
                        <div class="delete-x" style="visibility: hidden;">Ã—</div>
                    `;
                }
                listContainer.appendChild(itemDiv);
            }
        }

        function addTodo() {
            const text = input.value.trim();
            if (text && todos.length < 5) {
                todos.push({ text, completed: false });
                input.value = "";
                saveTodos();
                renderTodos();
            } else if (todos.length >= 5 && text) {
                // Visual feedback instead of alert
                input.classList.add("input-error");
                setTimeout(() => {
                    input.classList.remove("input-error");
                }, 400);
            }
        }

        function toggleTodo(index) {
            if (todos[index]) {
                todos[index].completed = !todos[index].completed;
                if (todos[index].completed) {
                    completedCount++;
                    todos[index].animating = true;
                    saveTodos();
                    renderTodos();
                    // Remove animation class after it finishes but keep completed state
                    setTimeout(() => {
                        if (todos[index]) {
                            todos[index].animating = false;
                            saveTodos();
                            renderTodos();
                        }
                    }, 500);
                } else {
                    if (completedCount > 0) completedCount--;
                    saveTodos();
                    renderTodos();
                }
            }
        }

        function deleteTodo(index) {
            todos.splice(index, 1);
            saveTodos();
            renderTodos();
        }

        function resetTodos() {
            todos = [];
            saveTodos();
            renderTodos();
        }

        let lastStreakClick = 0;
        function resetStreak() {
            const now = Date.now();
            if (now - lastStreakClick < 500) { // Double click detected
                completedCount = 0;
                saveTodos();
                renderTodos();
            }
            lastStreakClick = now;
        }

        // Drag and Drop Logic
        let draggedItemIndex = null;

        function handleDragStart(e) {
            draggedItemIndex = parseInt(this.dataset.index);
            setTimeout(() => this.classList.add('dragging'), 0);
            e.dataTransfer.effectAllowed = 'move';
        }

        function handleDragOver(e) {
            e.preventDefault();
            const draggingItem = document.querySelector('.dragging');
            if (!draggingItem) return;
            
            const siblings = [...listContainer.querySelectorAll('.todo-item:not(.dragging)')];
            const nextSibling = siblings.find(sibling => {
                const rect = sibling.getBoundingClientRect();
                return e.clientY <= rect.top + rect.height / 2;
            });

            if (nextSibling) {
                listContainer.insertBefore(draggingItem, nextSibling);
            } else {
                // If we're at the end, make sure we don't insert after empty slots
                const lastRealTask = siblings.filter(s => s.draggable).pop();
                if (lastRealTask) {
                    listContainer.insertBefore(draggingItem, lastRealTask.nextSibling);
                }
            }
        }

        function handleDrop(e) {
            e.preventDefault();
            updateTodosOrder();
        }

        function handleDragEnd() {
            this.classList.remove('dragging');
            draggedItemIndex = null;
            updateTodosOrder();
        }

        function updateTodosOrder() {
            const currentItems = [...listContainer.querySelectorAll('.todo-item')];
            const newTodos = [];
            currentItems.forEach(item => {
                if (item.draggable) {
                    const originalIndex = parseInt(item.dataset.index);
                    newTodos.push(todos[originalIndex]);
                }
            });
            
            // Check if order actually changed to avoid unnecessary renders
            if (JSON.stringify(newTodos) !== JSON.stringify(todos)) {
                todos = newTodos;
                saveTodos();
                renderTodos();
            }
        }

        input.onkeypress = (e) => {
            if (e.key === "Enter") addTodo();
        };

        resetBtn.onclick = resetTodos;

        applyTheme(currentTheme); // Apply theme on load
        renderTodos();
    </script>
</body>
</html>
